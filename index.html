<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8" />
<title>Mini Fortnite Lite</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #05070b;
    overflow: hidden;
    touch-action: none;
    font-family: system-ui, sans-serif;
    color: #fff;
  }

  #gameCanvas {
    display: block;
    margin: 0 auto;
    background: radial-gradient(circle at center, #1f2b3a 0, #05070b 70%);
  }

  #ui {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  #topBar {
    position: absolute;
    left: 10px;
    top: 10px;
    font-size: 13px;
    background: #0008;
    padding: 6px 10px;
    border-radius: 8px;
  }

  #stormBar {
    margin-top: 4px;
    width: 140px;
    height: 6px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
  }
  #stormBarFill {
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, #4cf, #f4f);
  }

  /* Toolbar */
  #toolbar {
    position: absolute;
    left: 50%;
    bottom: 10px;
    transform: translateX(-50%);
    display: flex;
    gap: 6px;
    pointer-events: auto;
  }
  .slot {
    width: 52px;
    height: 52px;
    border-radius: 8px;
    border: 2px solid #999;
    background: #0009;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    position: relative;
    color: #eee;
  }
  .slot.active {
    border-color: #ffd54f;
    box-shadow: 0 0 8px #ffd54f;
  }
  .slot span {
    text-align: center;
  }
  .slotIndex {
    position: absolute;
    left: 4px;
    bottom: 2px;
    font-size: 9px;
    opacity: 0.7;
  }

  /* Piler for å bytte våpen */
  .arrowBtn {
    position: absolute;
    bottom: 25px;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: #0008;
    border: 2px solid #888;
    color: #fff;
    font-size: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    user-select: none;
  }

  #leftArrow {
  left: calc(50% - 220px);
}

#rightArrow {
  right: calc(50% - 220px);
}


  .arrowBtn:active {
    background: #222;
    border-color: #fff;
  }

  /* Virtuell joystick (venstre) */
  #joystickArea {
    position: absolute;
    left: 0;
    bottom: 0;
    width: 45vw;
    height: 45vh;
    pointer-events: auto;
  }
  #joystickBase, #joystickStick {
    position: absolute;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.4;
  }
  #joystickBase {
    width: 120px;
    height: 120px;
    background: #fff3;
    border: 2px solid #fff5;
    display: none;
  }
  #joystickStick {
    width: 60px;
    height: 60px;
    background: #fff6;
    display: none;
  }

  /* Skyt-knapp (høyre) + hopp */
  #shootBtn, #jumpBtn {
    position: absolute;
    width: 70px;
    height: 70px;
    border-radius: 50%;
    pointer-events: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    user-select: none;
    font-size: 13px;
  }
  #shootBtn {
    right: 5vw;
    bottom: 12vh;
    background: #f44a;
    border: 2px solid #f88;
  }
  #jumpBtn {
    right: 20vw;
    bottom: 22vh;
    background: #4af8;
    border: 2px solid #8ff;
  }

  #gameOver {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    background: #000b;
    font-size: 24px;
    pointer-events: auto;
    z-index: 9999;
  }

  button {
    padding: 8px 16px;
    margin-top: 10px;
    border-radius: 6px;
    border: none;
    background: #3a8;
    color: #fff;
    font-size: 16px;
  }

  #resetBtn {
  position: absolute;
  left: 15px;
  bottom: 15px;
  width: 55px;
  height: 55px;
  border-radius: 50%;
  background: #c33c;
  border: 2px solid #f55;
  color: #fff;
  font-size: 26px;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
  user-select: none;
}


#resetBtn:active {
  background: #f55;
}

</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="ui">
  <div id="topBar">
    <div id="resetBtn">X</div>
    HP: <span id="hpText">100</span> |
    Bots: <span id="botsText">0</span> |
    Storm: <span id="stormText">Rolig</span> |
    Kills: <span id="killText">0</span> |
    Hi‑Score: <span id="hiScoreText">0</span><br/>
    Våpen: <span id="weaponText">Ingen</span>
    <div id="stormBar">
      <div id="stormBarFill"></div>
    </div>
  </div>

  <div id="toolbar"></div>
  <div id="leftArrow" class="arrowBtn">◀</div>
  <div id="rightArrow" class="arrowBtn">▶</div>

  <div id="joystickArea">
    <div id="joystickBase"></div>
    <div id="joystickStick"></div>
  </div>

  <div id="shootBtn">SKYT</div>
  <div id="jumpBtn">HOPP</div>

  <div id="gameOver">
    <div id="gameOverText"></div>
    <button id="restartBtn">Spill igjen</button>
  </div>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const size = Math.min(w, h);
    canvas.width = size;
    canvas.height = size;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  const hpText = document.getElementById('hpText');
  const botsText = document.getElementById('botsText');
  const stormText = document.getElementById('stormText');
  const stormBarFill = document.getElementById('stormBarFill');
  const weaponText = document.getElementById('weaponText');
  const gameOverEl = document.getElementById('gameOver');
  const gameOverText = document.getElementById('gameOverText');
  const restartBtn = document.getElementById('restartBtn');
  const killText = document.getElementById('killText');
  const hiScoreText = document.getElementById('hiScoreText');

  const joystickArea = document.getElementById('joystickArea');
  const joystickBase = document.getElementById('joystickBase');
  const joystickStick = document.getElementById('joystickStick');
  const shootBtn = document.getElementById('shootBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const toolbarEl = document.getElementById('toolbar');

  const leftArrow = document.getElementById('leftArrow');
  const rightArrow = document.getElementById('rightArrow');

  const W = () => canvas.width;
  const H = () => canvas.height;

  // Verden
  const world = {
    width: 3000,
    height: 3000
  };

  const player = {
    x: world.width / 2,
    y: world.height / 2,
    r: 16,
    speed: 2.4,
    vx: 0,
    vy: 0,
    hp: 100,
    aimAngle: 0,
    z: 0,
    vz: 0,
    onGround: true,
    jumpStrength: 7,
    gravity: 0.4,
    weaponSlots: [null, null, null, null, null],
    activeSlot: 0
  };

  let bullets = [];
  let bots = [];
  let blocks = [];
  let weapons = [];
  let lastTime = 0;
  let spawnTimer = 0;
  let weaponSpawnTimer = 0;
  let gameRunning = true;

  // Storm
  let stormRadius;
  let stormCenter;
  let stormShrinkTime = 60000; // 60 sek
  let stormElapsed = 0;
  let stormActive = true;

  // Kills / hi-score
  let kills = 0;
  let hiScore = 0;

  const weaponTypes = [
    { name: "Rifle", dmg: 20, color: "#4cf", fireRate: 220, bulletSpeed: 7 },
    { name: "Shotgun", dmg: 45, color: "#fa4", fireRate: 600, bulletSpeed: 6, spread: 0.3, pellets: 5 },
    { name: "SMG", dmg: 12, color: "#9f4", fireRate: 120, bulletSpeed: 6.5 },
    { name: "Sniper", dmg: 70, color: "#f4f", fireRate: 900, bulletSpeed: 10 },
    { name: "Pistol", dmg: 18, color: "#ddd", fireRate: 300, bulletSpeed: 6.5 }
  ];

  let shootPressed = false;
  let jumpPressed = false;
  let shootCooldown = 0;

  let joystickActive = false;
  let joystickCenter = { x: 0, y: 0 };
  let joystickVector = { x: 0, y: 0 };

  function initToolbar() {
    toolbarEl.innerHTML = "";
    for (let i = 0; i < 5; i++) {
      const slot = document.createElement("div");
      slot.className = "slot" + (i === player.activeSlot ? " active" : "");
      slot.dataset.index = i;
      const label = document.createElement("span");
      label.textContent = "Tom";
      slot.appendChild(label);
      const idx = document.createElement("div");
      idx.className = "slotIndex";
      idx.textContent = i + 1;
      slot.appendChild(idx);
      slot.addEventListener("click", () => {
        player.activeSlot = i;
        updateToolbar();
        updateWeaponText();
      });
      toolbarEl.appendChild(slot);
    }
  }

  function updateToolbar() {
    const slots = toolbarEl.querySelectorAll(".slot");
    slots.forEach((el, i) => {
      el.classList.toggle("active", i === player.activeSlot);
      const label = el.querySelector("span");
      const w = player.weaponSlots[i];
      label.textContent = w ? w.name : "Tom";
    });
  }

  function resetGame() {
    hiScore = parseInt(localStorage.getItem("mw_hiscore") || "0");
    kills = 0;
    killText.textContent = kills;
    hiScoreText.textContent = hiScore;

    player.x = world.width / 2;
    player.y = world.height / 2;
    player.vx = 0;
    player.vy = 0;
    player.z = 0;
    player.vz = 0;
    player.onGround = true;
    player.hp = 100;
    player.weaponSlots = [null, null, null, null, null];
    player.activeSlot = 0;
    bullets = [];
    bots = [];
    blocks = [];
    weapons = [];
    spawnTimer = 0;
    weaponSpawnTimer = 0;
    stormRadius = Math.min(world.width, world.height) * 0.45;
    stormCenter = { x: world.width / 2, y: world.height / 2 };
    stormElapsed = 0;
    stormActive = true;
    gameRunning = true;
    gameOverEl.style.display = 'none';
    lastTime = 0;
    shootPressed = false;
    jumpPressed = false;
    initBlocks();
    initBots();
    initToolbar();
    updateToolbar();
    updateWeaponText();
  }

  function initBlocks() {
    blocks = [];
    const count = 60;
    for (let i = 0; i < count; i++) {
      const w = 80 + Math.random() * 120;
      const h = 80 + Math.random() * 120;
      const x = 200 + Math.random() * (world.width - 400);
      const y = 200 + Math.random() * (world.height - 400);
      blocks.push({ x, y, w, h });
    }
  }

  function circleIntersectsRect(cx, cy, cr, rect) {
    const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
    const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return dx * dx + dy * dy < cr * cr;
  }

  function positionInsideBlocks(x, y, r) {
    for (const b of blocks) {
      if (circleIntersectsRect(x, y, r, b)) return true;
    }
    return false;
  }

  function safeRandomPosition(r, margin = 100) {
    let tries = 0;
    while (tries < 200) {
      const x = margin + Math.random() * (world.width - margin * 2);
      const y = margin + Math.random() * (world.height - margin * 2);
      if (!positionInsideBlocks(x, y, r)) return { x, y };
      tries++;
    }
    return { x: world.width / 2, y: world.height / 2 };
  }

  function initBots() {
    bots = [];
    for (let i = 0; i < 15; i++) spawnBot();
  }

  function spawnBot() {
    const r = 14;
    const pos = safeRandomPosition(r, 120);
    bots.push({
      x: pos.x,
      y: pos.y,
      r,
      speed: 1.6 + Math.random() * 0.5,
      hp: 60,
      wanderTimer: 0,
      vx: 0,
      vy: 0
    });
  }

  function spawnWeapon() {
    const r = 12;
    const pos = safeRandomPosition(r, 150);
    const type = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
    weapons.push({
      x: pos.x,
      y: pos.y,
      r,
      type
    });
  }

  function addWeaponToInventory(type) {
    for (let i = 0; i < player.weaponSlots.length; i++) {
      if (!player.weaponSlots[i]) {
        player.weaponSlots[i] = type;
        player.activeSlot = i;
        updateToolbar();
        updateWeaponText();
        return;
      }
    }
    player.weaponSlots[player.activeSlot] = type;
    updateToolbar();
    updateWeaponText();
  }

  function getActiveWeapon() {
    return player.weaponSlots[player.activeSlot] || null;
  }

  function updateWeaponText() {
    const w = getActiveWeapon();
    weaponText.textContent = w ? w.name : "Ingen";
  }

  function shootBullet() {
    const w = getActiveWeapon();
    if (!w) return;

    const baseAngle = player.aimAngle;
    const speed = w.bulletSpeed || 7;
    const dmg = w.dmg || 20;

    const pellets = w.pellets || 1;
    const spread = w.spread || 0;

    for (let i = 0; i < pellets; i++) {
      const angle = baseAngle + (Math.random() - 0.5) * spread;
      bullets.push({
        x: player.x,
        y: player.y,
        r: 4,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1200,
        dmg,
        color: w.color || "#fff"
      });
    }
  }

  // Input: skyting
  shootBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    shootPressed = true;
  });
  shootBtn.addEventListener('touchend', e => {
    e.preventDefault();
    shootPressed = false;
  });
  shootBtn.addEventListener('mousedown', e => {
    e.preventDefault();
    shootPressed = true;
  });
  shootBtn.addEventListener('mouseup', e => {
    e.preventDefault();
    shootPressed = false;
  });

  // Input: hopp
  jumpBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    jumpPressed = true;
  });
  jumpBtn.addEventListener('touchend', e => {
    e.preventDefault();
    jumpPressed = false;
  });
  jumpBtn.addEventListener('mousedown', e => {
    e.preventDefault();
    jumpPressed = true;
  });
  jumpBtn.addEventListener('mouseup', e => {
    e.preventDefault();
    jumpPressed = false;
  });

  // Piler for å bytte våpen
  leftArrow.addEventListener("click", () => {
    player.activeSlot = (player.activeSlot + 4) % 5;
    updateToolbar();
    updateWeaponText();
  });

  rightArrow.addEventListener("click", () => {
    player.activeSlot = (player.activeSlot + 1) % 5;
    updateToolbar();
    updateWeaponText();
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
  player.hp = 0; // instant death
});


  // Joystick
  function startJoystick(x, y) {
    joystickActive = true;
    joystickCenter.x = x;
    joystickCenter.y = y;
    joystickVector.x = 0;
    joystickVector.y = 0;
    joystickBase.style.left = x + 'px';
    joystickBase.style.top = y + 'px';
    joystickStick.style.left = x + 'px';
    joystickStick.style.top = y + 'px';
    joystickBase.style.display = 'block';
    joystickStick.style.display = 'block';
  }

  function moveJoystick(x, y) {
    if (!joystickActive) return;
    const dx = x - joystickCenter.x;
    const dy = y - joystickCenter.y;
    const dist = Math.hypot(dx, dy);
    const maxDist = 60;
    let nx = dx, ny = dy;
    if (dist > maxDist) {
      nx = dx / dist * maxDist;
      ny = dy / dist * maxDist;
    }
    joystickStick.style.left = (joystickCenter.x + nx) + 'px';
    joystickStick.style.top = (joystickCenter.y + ny) + 'px';

    joystickVector.x = nx / maxDist;
    joystickVector.y = ny / maxDist;

    if (dist > 5) {
      player.aimAngle = Math.atan2(joystickVector.y, joystickVector.x);
    }
  }

  function endJoystick() {
    joystickActive = false;
    joystickVector.x = 0;
    joystickVector.y = 0;
    joystickBase.style.display = 'none';
    joystickStick.style.display = 'none';
  }

  joystickArea.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0];
    startJoystick(t.clientX, t.clientY);
  });
  joystickArea.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.touches[0];
    moveJoystick(t.clientX, t.clientY);
  });
  joystickArea.addEventListener('touchend', e => {
    e.preventDefault();
    if (e.touches.length === 0) endJoystick();
  });

  joystickArea.addEventListener('mousedown', e => {
    e.preventDefault();
    startJoystick(e.clientX, e.clientY);
  });
  window.addEventListener('mousemove', e => {
    if (!joystickActive) return;
    moveJoystick(e.clientX, e.clientY);
  });
  window.addEventListener('mouseup', e => {
    if (joystickActive) endJoystick();
  });

  // Tastatur (for PC-testing)
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key >= '1' && e.key <= '5') {
      player.activeSlot = parseInt(e.key) - 1;
      updateToolbar();
      updateWeaponText();
    }
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  restartBtn.addEventListener('click', () => {
    resetGame();
  });

  function gameOver(win) {
    gameRunning = false;
    gameOverText.textContent = win ? 'Victory Royale!' : 'Du døde!';
    gameOverEl.style.display = 'flex';
  }

  function update(dt) {
    if (!gameRunning) return;

    // Bevegelse (mobil joystick + tastatur)
    let moveX = joystickVector.x;
    let moveY = joystickVector.y;

    if (keys['w'] || keys['arrowup']) moveY -= 1;
    if (keys['s'] || keys['arrowdown']) moveY += 1;
    if (keys['a'] || keys['arrowleft']) moveX -= 1;
    if (keys['d'] || keys['arrowright']) moveX += 1;

    const len = Math.hypot(moveX, moveY) || 1;
    moveX /= len;
    moveY /= len;

    const moveSpeed = player.speed * (dt / 16.67);
    player.vx = moveX * moveSpeed;
    player.vy = moveY * moveSpeed;

    // Hopp/fysikk
    if ((jumpPressed || keys[' ']) && player.onGround) {
      player.vz = player.jumpStrength;
      player.onGround = false;
    }
    player.vz -= player.gravity * (dt / 16.67);
    player.z += player.vz * (dt / 16.67);
    if (player.z <= 0) {
      player.z = 0;
      player.vz = 0;
      player.onGround = true;
    }

    // Kollisjon med blokker (2D top-down)
    let newX = player.x + player.vx;
    let newY = player.y + player.vy;

    function collidesCircleRect(cx, cy, cr, rect) {
      const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
      const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return dx * dx + dy * dy < cr * cr;
    }

    for (const b of blocks) {
      if (collidesCircleRect(newX, player.y, player.r, b)) {
        newX = player.x;
      }
      if (collidesCircleRect(player.x, newY, player.r, b)) {
        newY = player.y;
      }
    }

    player.x = Math.max(player.r, Math.min(world.width - player.r, newX));
    player.y = Math.max(player.r, Math.min(world.height - player.r, newY));

    // Storm
    if (stormActive) {
      stormElapsed += dt;
      const t = Math.min(1, stormElapsed / stormShrinkTime);
      const minRadius = 300;
      stormRadius = Math.max(minRadius, Math.min(world.width, world.height) * 0.45 * (1 - t) + minRadius * t);
      stormBarFill.style.width = (100 - t * 100) + "%";
      stormText.textContent = t < 1 ? "Krymper" : "Full storm";

      const dxs = player.x - stormCenter.x;
      const dys = player.y - stormCenter.y;
      const dist = Math.hypot(dxs, dys);
      if (dist > stormRadius) {
        player.hp -= 8 * (dt / 1000);
      }
    }

    // Bot-spawn (maks 50)
    spawnTimer += dt;
    if (spawnTimer > 4000 && bots.length < 35) {
      spawnTimer = 0;
      spawnBot();
    }

    // Våpen-spawn (litt hyppigere + flere)
    weaponSpawnTimer += dt;
    if (weaponSpawnTimer > 1500 && weapons.length < 30) {
      weaponSpawnTimer = 0;
      spawnWeapon();
    }

    // Bots AI
    for (const bot of bots) {
      const dx = player.x - bot.x;
      const dy = player.y - bot.y;
      const dist = Math.hypot(dx, dy) || 1;

      const speed = bot.speed * (dt / 16.67);
      let dirX = dx / dist;
      let dirY = dy / dist;

      // Litt random strafe
      bot.wanderTimer -= dt;
      if (bot.wanderTimer <= 0) {
        bot.wanderTimer = 1000 + Math.random() * 1500;
        const angle = (Math.random() - 0.5) * 1.2;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const sx = dirX * cos - dirY * sin;
        const sy = dirX * sin + dirY * cos;
        bot.vx = sx * speed;
        bot.vy = sy * speed;
      }

      let newBX = bot.x + bot.vx;
      let newBY = bot.y + bot.vy;

      for (const b of blocks) {
        if (collidesCircleRect(newBX, bot.y, bot.r, b)) newBX = bot.x;
        if (collidesCircleRect(bot.x, newBY, bot.r, b)) newBY = bot.y;
      }

      bot.x = Math.max(bot.r, Math.min(world.width - bot.r, newBX));
      bot.y = Math.max(bot.r, Math.min(world.height - bot.r, newBY));

      // Skade spiller ved nærkontakt
      if (dist < bot.r + player.r + 4 && player.z < 10) {
        player.hp -= 15 * (dt / 1000);
      }
    }

    // Bullets
    for (const b of bullets) {
      b.x += b.vx * (dt / 16.67);
      b.y += b.vy * (dt / 16.67);
      b.life -= dt;
    }
    bullets = bullets.filter(b =>
      b.life > 0 &&
      b.x > -50 && b.x < world.width + 50 &&
      b.y > -50 && b.y < world.height + 50
    );

    // Bullet vs bots + kills / hi-score
    for (const b of bullets) {
      for (const bot of bots) {
        const dx = b.x - bot.x;
        const dy = b.y - bot.y;
        const dist = Math.hypot(dx, dy);
        if (dist < b.r + bot.r) {
          bot.hp -= b.dmg;
          b.life = 0;
        }
      }
    }

    for (const bot of bots) {
      if (bot.hp <= 0) {
        kills++;
        killText.textContent = kills;
        if (kills > hiScore) {
          hiScore = kills;
          hiScoreText.textContent = hiScore;
          localStorage.setItem("mw_hiscore", hiScore);
        }
      }
    }
    bots = bots.filter(bot => bot.hp > 0);

    // Plukk opp våpen
    for (let i = weapons.length - 1; i >= 0; i--) {
      const w = weapons[i];
      const dist = Math.hypot(player.x - w.x, player.y - w.y);
      if (dist < player.r + w.r + 6) {
        addWeaponToInventory(w.type);
        weapons.splice(i, 1);
      }
    }

    // Skyting
    shootCooldown -= dt;
    if (shootCooldown < 0) shootCooldown = 0;
    if (shootPressed || keys['mouse1']) {
      const w = getActiveWeapon();
      if (w && shootCooldown === 0) {
        shootBullet();
        shootCooldown = w.fireRate || 250;
      }
    }

    // Oppdater UI
    hpText.textContent = Math.max(0, player.hp).toFixed(0);
    botsText.textContent = bots.length;
    updateWeaponText();

    if (player.hp <= 0) {
      player.hp = 0;
      gameOver(false);
    }

    // Victory Royale når alle bots er døde
    if (bots.length === 0 && gameRunning) {
      gameOver(true);
    }
  }

  function draw() {
    ctx.clearRect(0, 0, W(), H());

    // Kamera følger spiller
    const camX = player.x - W() / 2;
    const camY = player.y - H() / 2;

    ctx.save();
    ctx.translate(-camX, -camY);

    // Bakgrunn
    ctx.fillStyle = "#10151c";
    ctx.fillRect(0, 0, world.width, world.height);

    // Storm
    if (stormActive) {
      ctx.save();
      ctx.fillStyle = "rgba(120, 180, 255, 0.08)";
      ctx.beginPath();
      ctx.arc(stormCenter.x, stormCenter.y, stormRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Blokker
    ctx.fillStyle = "#1f2933";
    for (const b of blocks) {
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.strokeStyle = "#2f3b4a";
      ctx.lineWidth = 2;
      ctx.strokeRect(b.x, b.y, b.w, b.h);
    }

    // Våpen på bakken
    for (const w of weapons) {
      ctx.fillStyle = w.type.color;
      ctx.beginPath();
      ctx.arc(w.x, w.y, w.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#000";
      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(w.type.name[0], w.x, w.y + 3);
    }

    // Bots
    for (const bot of bots) {
      ctx.save();
      ctx.translate(bot.x, bot.y);
      ctx.fillStyle = "#f55";
      ctx.beginPath();
      ctx.arc(0, 0, bot.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#000";
      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("BOT", 0, 3);
      ctx.restore();
    }

    // Bullets
    for (const b of bullets) {
      ctx.fillStyle = b.color || "#fffb";
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Spiller
    ctx.save();
    ctx.translate(player.x, player.y - player.z);
    ctx.rotate(player.aimAngle);
    ctx.fillStyle = "#4cf";
    ctx.beginPath();
    ctx.arc(0, 0, player.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.fillRect(player.r - 4, -3, 12, 6);
    ctx.restore();

    ctx.restore();
  }

  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  resetGame();
  requestAnimationFrame(loop);
</script>
</body>
</html>
